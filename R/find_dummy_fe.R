# Find which variables are interaction terms of each other

example.find_dummy_sets = function() {
  n = 100
  dat = tibble(d1 = sample(0:1,n, replace=TRUE), i1 = sample(1:5,n, replace=TRUE), i2 = sample(1:5,n, replace=TRUE), i3 = sample(1:10,n, replace=TRUE), s1 = sample(letters,n, replace=TRUE), s1_i1 = paste0(s1,".",i1), s1_i2_i1 = paste0(s1,"_",i2,"_",i1))

  #dat$i1[3] = NA
  dmat = dummies::dummy(dat$i1)
  dmat[c(3,10), ]=NA

  dmat2 = dummies::dummy(dat$i2)
  dmat2[c(2,5), ]=NA

  dat = cbind(dat,dmat[,-3], d2 = dat$d1, dmat2)


  find_dummy_sets(dat)

  dummy_set_to_integer(dat, 8, 11)

  colnames(dat)

}


# A dummy set is intuitively the set of dummy variables generated by a factor variable
#
# Formally we identify dummy sets in a data frame that satisfy the following conditions:

# 1. Each variable in the set is a dummy
# 2. The sum of the dummy set variable is a dummy.
#    If the sum is 1 everywhere we havea"complete" dummy set
# 3. NA values must be in the same rows for all dummies in the set
# 4. The dummy set columns must be neighbours in the data frame

find_dummy_sets = function(dat,cols=colnames(dat)) {
  restore.point("find_dummy_sets")
  # Only consider numeric and logical columns
  is_num = sapply(dat[cols], function(v) {
    if (is.character(v) | is.factor(v)) return(FALSE)
    return(TRUE)
  })
  cols = cols[is_num]
  idat = lapply(dat[cols], as.integer)

  # We only consider TRUE dummies that take both 0 and 1
  is_dummy = sapply(idat, function(v) {
    r = suppressWarnings(range(v, na.rm=TRUE))
    isTRUE(min(r) == 0 & max(r)==1)
  })
  cols = cols[is_dummy]

  if (length(cols)<2) return(NULL)

  idat = idat[cols]

  col_nums = match(cols, colnames(dat))

  # Remove standalone dummy columns (with no dummy neighbour)
  diff = col_nums[-1] - col_nums[-length(col_nums)]
  dist.left = c(2,diff)
  dist.right = c(diff,2)


  stand_alone = dist.left > 1 & dist.right > 1
  if (sum(stand_alone)>0) {
    cols = cols[!stand_alone]
    col_nums = col_nums[!stand_alone]
    idat = idat[!stand_alone]
    dist.left = dist.left[!stand_alone]
    dist.right = dist.right[!stand_alone]
  }

  # Now we find the rows with NA
  na_li = lapply(idat, function(v) which(is.na(v)))

  n = length(cols)
  na_group = rep(1, n)
  cur_group = 1
  for (i in 2:n) {
    if (!identical(na_li[[i]], na_li[[i-1]])) {
      cur_group = cur_group +1
    }
    na_group[i] = cur_group
  }

  na_group_left = c(0,na_group[-length(na_group)])
  new_group = na_group_left != na_group | dist.left > 1

  n = length(cols)
  sets.li = vector("list",n-1)
  counter = 0
  sc = 1
  found_ec = -1
  while(sc < n & found_ec < n) {
    if (new_group[sc]) {
      start_ec = sc+1
      dummy_sum = idat[[sc]]
    } else if (new_group[found_ec+1]) {
      # continue with new group right of found_ec
      sc = found_ec+1
      start_ec = sc+1
      dummy_sum = idat[[sc]]
    } else {
      # continue with sc+1 within the same group
      # for ec we immediately begin with found_ec+1
      start_ec = found_ec+1
      dummy_sum = dummy_sum - idat[[sc-1]]
    }
    found_ec = -1
    for (ec in start_ec:n) {
      if (new_group[ec]) break
      new_dummy_sum = dummy_sum + idat[[ec]]
      is_set = is_dummy_set_sum(new_dummy_sum)
      if (is_set==0) break
      dummy_sum = new_dummy_sum
      found_ec = ec
      #cat("\n", "found_ec=", found_ec, "is_set=",is_set)
      if (is_set==2) break
    }
    if (found_ec>0) {
      counter = counter+1
      #cat("\n", counter, "found_ec=", found_ec, "is_set=",is_set)
      sets.li[[counter]] = c(sc =sc, ec=found_ec, complete = 1L*(is_set==2))
    }
    sc = sc+1
  }

  if (counter==0) return(NULL)

  dsets = do.call(rbind, sets.li[1:counter])

  data.frame(scol = cols[dsets[,1]], ecol = cols[dsets[,2]], scolnum=col_nums[dsets[,1]], ecolnum=col_nums[dsets[,2]], complete=dsets[,3])

}

is_dummy_set_sum = function(v) {
  r = suppressWarnings(range(v, na.rm=TRUE))
  if (min(r)<0 | max(r) > 1) return(0)
  # Full set: all dummies add up to 1 (unless NA)
  if (min(r)==1) return(2)

  # Not a full set: some dummies are still 0
  return(1)
}


dummy_set_to_integer = function(dat, start_col, end_col) {
  cols = start_col:end_col
  factor = as.integer(dat[[start_col]])

  n = end_col-start_col +1
  for (i in seq_len(n-1)) {
    factor = factor + as.integer(dat[[start_col+i]])*(i+1)
  }
  factor
}
